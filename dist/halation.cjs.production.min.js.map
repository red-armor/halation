{"version":3,"file":"halation.cjs.production.min.js","sources":["../src/types/module.ts","../src/types/loadStrategy.ts","../src/Node.ts","../src/logger.ts","../src/Module.ts","../src/commons.ts","../src/BlockNode.tsx","../src/LoadManager.ts","../src/Tracker.ts","../src/path.ts","../src/EffectNode.ts","../src/EventTracker.ts","../src/Halation.ts"],"sourcesContent":["import { Strategy } from './loadStrategy';\n\nexport enum ModuleName {\n  Model = 'model',\n  Component = 'component',\n}\n\nexport type ModuleGetter = () => Function | undefined;\n\nexport interface GetComponent {\n  (): Promise<Function>;\n}\n\nexport interface ModuleProps {\n  name: string;\n  getModel?: Function;\n  getComponent: GetComponent;\n  strategies: Array<Strategy>;\n}\n\nexport enum ModuleStatus {\n  Idle,\n  Pending,\n  Loaded,\n  Error,\n}\n\nexport interface ESModule {\n  ['__esModule']: boolean;\n  default: Function;\n}\n\nexport type RawModule = ESModule | Function;\n\nexport type ResolvedModule<T extends RawModule> = T extends ESModule\n  ? T['default']\n  : T;\n","export enum StrategyType {\n  flags = 'flags',\n  event = 'event',\n  runtime = 'runtime',\n}\n\nexport interface Strategy {\n  type: StrategyType;\n  resolver: (value?: any) => boolean;\n}\n\nexport interface LoadStrategyProps {\n  strategy: Strategy;\n}\n","import { NodeProps, NodeRenderProps, Strategy } from './types';\n\nclass Node {\n  private name: string;\n  private key: string;\n  private prevSibling: string;\n  private nextSibling: string;\n  private type: string;\n  private children: Array<string>;\n  private strategies?: Array<Strategy>;\n\n  constructor(props: NodeProps) {\n    const {\n      key,\n      type,\n      prevSibling,\n      nextSibling,\n      children,\n      name,\n      strategies,\n    } = props;\n    this.key = key;\n    this.name = name;\n    this.prevSibling = prevSibling;\n    this.nextSibling = nextSibling;\n    this.type = type || 'block';\n    this.children = children;\n    this.strategies = strategies;\n  }\n\n  getChildKeys(): Array<string> {\n    return this.children;\n  }\n\n  getNextSibling(): string | null {\n    return this.nextSibling;\n  }\n\n  getPrevSibling(): string | null {\n    return this.prevSibling;\n  }\n\n  getName(): string {\n    return this.name;\n  }\n\n  getKey(): string {\n    return this.key;\n  }\n\n  getType(): string {\n    return this.type;\n  }\n\n  getStrategies(): Array<Strategy> | undefined {\n    return this.strategies;\n  }\n\n  getRenderProps(): NodeRenderProps {\n    return {\n      key: this.key,\n      name: this.name,\n      type: this.type,\n    };\n  }\n}\n\nexport default Node;\n","export const warn = (...args: Array<any>) => {\n  console.warn.call(null, ...args);\n};\n\nexport const log = (...args: Array<any>) => {\n  console.log.call(null, ...args);\n};\n\nexport const error = (props: { type: string; message: string }) => {\n  const { message, type } = props;\n  console.error(message, type);\n};\n\nexport const logActivity = (\n  moduleName: string,\n  { message, value }: { message: string; value?: any }\n) => {\n  const title: string = `[${moduleName}]`;\n  const titleStyle = 'color: #7cb305; font-weight: bold';\n  const messageStyle = 'color: #ff4d4f; font-weight: bold';\n\n  if (process && process.env.NODE_ENV !== 'production') {\n    console.log.apply(null, [\n      '%c' + title + ' %c' + message,\n      titleStyle,\n      messageStyle,\n      value ? value : '',\n      Date.now(),\n    ]);\n  }\n};\n","import {\n  ModuleProps,\n  GetComponent,\n  ModuleStatus,\n  RawModule,\n  ModuleName,\n  ModuleGetter,\n  ESModule,\n  Strategy,\n} from './types';\nimport { error, logActivity } from './logger';\n\nclass Module {\n  private _name: string;\n  private _getModel?: Function;\n  private _getComponent: GetComponent;\n  private statusMap: Map<ModuleName, ModuleStatus>;\n  private resolversMap: Map<ModuleName, Array<Function>>;\n  private resolvedModulesMap: Map<ModuleName, Function | null>;\n  private _strategies: Array<Strategy>;\n\n  constructor(props: ModuleProps) {\n    const { name, getModel, getComponent, strategies } = props;\n    this._name = name;\n    this._getModel = getModel;\n    this._getComponent = getComponent;\n    this.statusMap = new Map<ModuleName, ModuleStatus>([\n      [ModuleName.Model, ModuleStatus.Idle],\n      [ModuleName.Component, ModuleStatus.Idle],\n    ]);\n    this.resolversMap = new Map<ModuleName, Array<Function>>([\n      [ModuleName.Model, [] as Array<Function>],\n      [ModuleName.Component, [] as Array<Function>],\n    ]);\n    this.resolvedModulesMap = new Map<ModuleName, Function | null>([\n      [ModuleName.Model, null],\n      [ModuleName.Component, null],\n    ]);\n    this._strategies = strategies || [];\n\n    logActivity('Module', {\n      message: `create ${name} Module`,\n    });\n  }\n\n  getName(): string {\n    return this._name;\n  }\n\n  getComponent(): GetComponent {\n    return this._getComponent;\n  }\n\n  getStrategies(): Array<Strategy> {\n    return this._strategies;\n  }\n\n  getModel(): Function | undefined {\n    return this._getModel;\n  }\n\n  resolveModule<T extends RawModule>(module: T): Function {\n    return module && (module as ESModule).__esModule\n      ? (module as ESModule).default\n      : (module as Function);\n  }\n\n  load(\n    moduleName: ModuleName,\n    getter: ModuleGetter\n  ): Promise<Function> | Function {\n    const currentStatus = this.statusMap.get(moduleName);\n    // If module has been loaded already, then return directly.\n    if (currentStatus === ModuleStatus.Loaded) {\n      logActivity('Module', {\n        message: `load module ${this._name} ${moduleName} from cache`,\n      });\n      return this.resolvedModulesMap.get(moduleName) as Function;\n    }\n\n    return new Promise(resolve => {\n      switch (currentStatus) {\n        case ModuleStatus.Idle:\n          this.resolversMap.get(moduleName)?.push(resolve);\n          logActivity('Module', {\n            message: `start load module ${this._name} ${moduleName}`,\n          });\n          this.statusMap.set(moduleName, ModuleStatus.Pending);\n          break;\n        case ModuleStatus.Pending:\n          this.resolversMap.get(moduleName)?.push(resolve);\n          return;\n      }\n\n      const fn = getter.call(this);\n\n      if (fn) {\n        // __webpack_require__ will not return a Promise, so it need to wrapped\n        // with Promise.resolve.\n        Promise.resolve(fn.call(this)).then(\n          rawModule => {\n            const module = this.resolveModule(rawModule as RawModule);\n            const resolvers = this.resolversMap.get(moduleName) || [];\n            resolvers.forEach(resolver => resolver(module));\n            this.resolvedModulesMap.set(moduleName, module);\n            logActivity('Module', {\n              message: `finish load module ${this._name} ${moduleName}`,\n            });\n            this.resolversMap.set(moduleName, []);\n            this.statusMap.set(moduleName, ModuleStatus.Loaded);\n          },\n          () => {\n            error({\n              type: 'module',\n              message: `'load' ${moduleName} fails`,\n            });\n          }\n        );\n      }\n    });\n  }\n\n  loadModel(): Promise<Function> | Function {\n    return this.load(ModuleName.Model, this.getModel);\n  }\n\n  loadComponent(): Promise<Function> | Function {\n    return this.load(ModuleName.Component, this.getComponent);\n  }\n}\n\nexport default Module;\n","const toString = Function.call.bind<Function>(Object.prototype.toString);\nexport const isFunction = (fn: any): boolean => typeof fn === 'function';\nexport const isString = (o: any) => toString(o) === '[object String]';\nexport const isPlainObject = (o: any) => toString(o) === '[object Object]';\nexport const isPromise = (o: any) =>\n  typeof o === 'object' && typeof o.then === 'function';\n\nexport const reflect = (p: Promise<any>) =>\n  p.then(\n    value => {\n      return { value, success: true };\n    },\n    value => {\n      return { value, success: false };\n    }\n  );\n\nexport const settledPromise = (ps: Array<Promise<any>>) =>\n  Promise.all(ps.map(p => reflect(p)));\n\nexport const canIUseProxy = () => {\n  try {\n    new Proxy({}, {}) // eslint-disable-line\n  } catch (err) {\n    return false;\n  }\n\n  return true;\n};\n\nexport const createHiddenProperty = (\n  target: object,\n  prop: PropertyKey,\n  value: any\n) => {\n  Object.defineProperty(target, prop, {\n    value,\n    enumerable: false,\n    writable: true,\n  });\n};\n\nexport const hasSymbol = typeof Symbol !== 'undefined';\nexport const TRACKER: unique symbol = hasSymbol\n  ? Symbol('tracker')\n  : ('__tracker__' as any);\n\nexport const isTrackable = (o: any) => { // eslint-disable-line\n  return ['[object Object]', '[object Array]'].indexOf(toString(o)) !== -1;\n};\n","import React, {\n  FC,\n  useRef,\n  useState,\n  Fragment,\n  forwardRef,\n  useCallback,\n  createElement,\n  FunctionComponentElement,\n} from 'react';\nimport invariant from 'invariant';\nimport { BlockNodeProps, BlockWrapperProps, BlockNodeState } from './types';\nimport { logActivity } from './logger';\nimport { isPromise, settledPromise } from './commons';\n\nconst BlockWrapper: FC<BlockNodeProps> = props => {\n  const { hooks, block, moduleMap, loadManagerMap, blockRenderFn } = props;\n  const [wrapper, setWrapper] = useState<BlockNodeState>({});\n  const blockKey = block.getKey();\n  const moduleName = block.getName();\n  const blockRef = useRef();\n  const isLoadingRef = useRef(false);\n  const isMountedRef = useRef(false);\n  const loadManager = loadManagerMap.get(blockKey)!;\n\n  const unsubscribeLoadRoutine = useRef<Function | null>(null);\n\n  const loadRoutine = useCallback(() => {\n    const shouldLoadModule = loadManager?.shouldModuleLoad();\n    if (isPromise(shouldLoadModule)) {\n      (shouldLoadModule as Promise<boolean>).then(falsy => {\n        if (falsy) loadAndForceUpdate();\n      });\n    } else if (shouldLoadModule) {\n      loadAndForceUpdate();\n    }\n  }, []); // eslint-disable-line\n\n  const forceUpdate = useCallback(result => {\n    const [modelResult, componentResult] = result;\n    const state: BlockNodeState = {};\n    if (modelResult.success) {\n      state.model = modelResult.value;\n    }\n\n    if (componentResult.success) {\n      state.Component = componentResult.value;\n    }\n    setWrapper(state);\n  }, []) // eslint-disable-line\n\n  const loadAndForceUpdate = useCallback(() => {\n    logActivity('BlockNode', {\n      message: `Trigger 'loadAndForceUpdate'`,\n    });\n    if (unsubscribeLoadRoutine.current)\n      unsubscribeLoadRoutine.current?.call(null);\n    if (isLoadingRef.current) return;\n    const module = moduleMap.get(moduleName);\n    if (module) {\n      hooks.register.call(blockKey, block);\n      const model = module.loadModel();\n      const component = module.loadComponent();\n\n      if (isPromise(model) || isPromise(component)) {\n        const loadModelTask = Promise.resolve(module.loadModel());\n        const loadComponentTask = Promise.resolve(module.loadComponent());\n        settledPromise([loadModelTask, loadComponentTask]).then(result => {\n          forceUpdate(result);\n        });\n      } else {\n        logActivity('BlockNode', {\n          message: `load component & model directly..`,\n        });\n        forceUpdate([\n          {\n            success: true,\n            value: model,\n          },\n          {\n            success: true,\n            value: component,\n          },\n        ]);\n      }\n\n      // TODO: temp to wrapper with Promise\n    }\n  }, []); // eslint-disable-line\n\n  // 在最开始的时候，判断一下是否进行module的加载；\n  if (!isMountedRef.current) {\n    // In a condition, when invoke loadRoutine, model and module have already loaded.\n    // it will trigger forceUpdate directly. Because there is no limit on trigger forceUpdate.\n    // if `isMountedRef` is putted in `useEffect`, it will never be called and lost into\n    // render loop!!!\n    isMountedRef.current = true;\n    unsubscribeLoadRoutine.current = loadManager.bindLoadRoutine(loadRoutine);\n    loadRoutine();\n  }\n\n  const Helper = () => {\n    return null;\n  };\n\n  if (!wrapper.Component) return null;\n\n  let blockRenderer = null;\n\n  if (typeof blockRenderFn === 'function') {\n    blockRenderer = blockRenderFn(block.getRenderProps());\n  }\n\n  const RefForwardingWrapper = forwardRef<any, BlockWrapperProps>(\n    (props, ref) => {\n      return createElement(wrapper.Component as FC<any>, {\n        ...props,\n        $_modelKey: loadManager.getKey(),\n        forwardRef: ref,\n      });\n    }\n  );\n\n  if (blockRenderer) {\n    return (\n      <Fragment>\n        {createElement(\n          blockRenderer,\n          props,\n          <RefForwardingWrapper {...props} ref={blockRef} />\n        )}\n        <Helper />\n      </Fragment>\n    );\n  }\n\n  return (\n    <Fragment>\n      <RefForwardingWrapper {...props} ref={blockRef} />\n      <Helper />\n    </Fragment>\n  );\n};\n\nconst BlockNode: FC<BlockNodeProps> = props => {\n  const { block, nodeMap, blockRenderFn, addBlockLoadManager, ...rest } = props;\n  const children: Array<FunctionComponentElement<BlockNodeProps>> = [];\n  const childKeys = block.getChildKeys();\n  const blockKey = block.getKey();\n  const moduleName = block.getName();\n  const moduleMap = props.moduleMap;\n  const module = moduleMap.get(moduleName)!;\n\n  invariant(\n    module,\n    `module ${moduleName} is required to register first. Please check whether ` +\n      `module ${moduleName} is defined in 'registers' props`\n  );\n\n  // block strategy comes first, then from module...\n  const strategies = block.getStrategies() || module.getStrategies() || [];\n  addBlockLoadManager({\n    blockKey,\n    moduleName,\n    strategies,\n  });\n\n  logActivity('BlockNode', {\n    message: 'render block node',\n    value: block,\n  });\n\n  childKeys.forEach(childKey => {\n    const node = nodeMap.get(childKey);\n    if (node) {\n      children.push(\n        createElement(\n          BlockNode,\n          {\n            key: childKey,\n            block: node,\n            nodeMap,\n            blockRenderFn,\n            addBlockLoadManager,\n            ...rest,\n          },\n          null\n        )\n      );\n    }\n  });\n\n  return createElement(BlockWrapper, props, children);\n};\n\nexport default BlockNode;\n","import {\n  Store,\n  Strategy,\n  ModuleMap,\n  StrategyType,\n  ProxyEvent,\n  DispatchEvent,\n  LockCurrentLoadManager,\n  ReleaseCurrentLoadManager,\n  LoadManagerConstructorProps,\n} from './types';\nimport { isFunction, isPromise } from './commons';\nimport { logActivity } from './logger';\n\n/**\n * loadManager需要在进行渲染之前就要处理一直，这样在`BlockNode`渲染的时候，可以直接对那些不需要判断的\n * 组件直接进行加载；\n */\nclass LoadManager {\n  private _key: string;\n  readonly _store: Store;\n  readonly strategies: Array<Strategy>;\n  readonly _moduleName: string;\n  readonly _moduleMap: ModuleMap;\n  readonly _lockCurrentLoadManager: LockCurrentLoadManager;\n  readonly _releaseCurrentLoadManager: ReleaseCurrentLoadManager;\n  readonly _proxyEvent: ProxyEvent;\n  private _dispatchEvent: DispatchEvent;\n  private teardownEffects: Array<Function>;\n  private _runtimeVerifyEffect: null | Function;\n  private _loadRoutine: Function | null;\n\n  constructor(props: LoadManagerConstructorProps) {\n    const {\n      store,\n      blockKey,\n      moduleName,\n      strategies,\n      moduleMap,\n      proxyEvent,\n      dispatchEvent,\n      lockCurrentLoadManager,\n      releaseCurrentLoadManager,\n    } = props;\n\n    this._key = blockKey;\n    this._store = store;\n    this.strategies = this.sort(strategies);\n    this._moduleName = moduleName;\n    this._moduleMap = moduleMap;\n    this._lockCurrentLoadManager = lockCurrentLoadManager;\n    this._releaseCurrentLoadManager = releaseCurrentLoadManager;\n    this._proxyEvent = proxyEvent;\n    this._dispatchEvent = dispatchEvent;\n    this.teardownEffects = [];\n    this._runtimeVerifyEffect = null;\n    this._loadRoutine = null;\n  }\n\n  getKey() {\n    return this._key;\n  }\n\n  addTeardown(fn: Function) {\n    this.teardownEffects.push(fn);\n  }\n\n  teardown() {\n    this.teardownEffects.forEach(fn => fn());\n  }\n\n  /**\n   *\n   * @param strategies\n   * 按照'flags', 'event', 'runtime'的顺序进行排序；因为只有在'flags'和'event'\n   * 层级都加载完毕其实'runtime'层面才需要开始加载（这个时候其实单独触发的model的加载）；\n   * 之所以，将flags单独放出来，因为假如说flags都没有过的话，其实runtime的model都\n   * 不需要进行加载的；\n   */\n  sort(strategies: Array<Strategy>): Array<Strategy> {\n    const typeMap = {\n      flags: 0,\n      event: 1,\n      runtime: 2,\n    };\n    return strategies.sort((a, b) => {\n      return typeMap[a.type] - typeMap[b.type];\n    });\n  }\n\n  update() {\n    this.teardown();\n    if (this._loadRoutine) this._loadRoutine();\n  }\n\n  mountModel(\n    resolver: Function,\n    modelInstance: any,\n    initialValue: any = {}\n  ): boolean {\n    const modelKey = this._key;\n    this._store.injectModel(modelKey, modelInstance, initialValue);\n    const base = this._store.getState();\n\n    // TODO: If injected model is pending with effects. base[modelKey]\n    // may get old value...\n    const currentModelState = base[modelKey];\n    const falsy = resolver(currentModelState);\n\n    if (!falsy) {\n      this._store.subscribe(this.update.bind(this));\n    }\n\n    return !!falsy;\n  }\n\n  startVerifyRuntime(resolver: Function): Promise<boolean> | boolean {\n    if (typeof this._runtimeVerifyEffect === 'function') {\n      this._runtimeVerifyEffect();\n      this._runtimeVerifyEffect = null;\n    }\n\n    logActivity('LoadManager', {\n      message: 'start verify runtime strategy',\n    });\n\n    const modelCreator = this._moduleMap.get(this._moduleName)?.loadModel();\n    let modelInstance = null;\n    if (isPromise(modelCreator)) {\n      return (modelCreator as Promise<Function>)\n        .then(m => {\n          const modelInstance = m.call(null);\n          return this.mountModel(resolver, modelInstance, {});\n        })\n        .catch(err => {\n          logActivity('LoadManager', {\n            message: `Has error on verify runtime..${err}`,\n          });\n          return false;\n        });\n    } else if (isFunction(modelCreator)) {\n      modelInstance = (modelCreator as Function).call(null);\n      return this.mountModel(resolver, modelInstance, {});\n    }\n\n    return false;\n  }\n\n  /**\n   * 整个strategy的处理需要是一个同步的\n   */\n  shouldModuleLoad(): boolean | Promise<boolean> {\n    const len = this.strategies.length;\n    this._lockCurrentLoadManager(this);\n    // debugger\n\n    for (let i = 0; i < len; i++) {\n      const strategy = this.strategies[i];\n      const { type, resolver } = strategy;\n      let value: boolean = false;\n\n      switch (type) {\n        case StrategyType.event:\n          value = !!resolver({\n            event: this._proxyEvent,\n            dispatchEvent: this._dispatchEvent,\n          });\n          break;\n        // 如果说是runtime的话，首先需要先加载model；运行一次resolver将需要\n        // 监听的属性进行绑定。\n        case StrategyType.runtime:\n          return this.startVerifyRuntime(resolver);\n      }\n      // TODO: 临时注释掉\n      if (!value) {\n        // should release current load manager before return\n        this._releaseCurrentLoadManager();\n        return false;\n      }\n    }\n    this._releaseCurrentLoadManager();\n\n    return true;\n  }\n\n  bindLoadRoutine(loadRoutine: Function): Function {\n    this._loadRoutine = loadRoutine;\n    return () => (this._loadRoutine = null);\n  }\n}\n\nexport default LoadManager;\n","import { createHiddenProperty, isTrackable, TRACKER } from './commons';\nimport { TrackerConstructor, TrackerConstructorProps } from './types';\n\nconst Tracker = (function({\n  base,\n  path = [],\n  reportAccessPaths,\n}: TrackerConstructorProps) {\n  let tracker = base;\n\n  if (isTrackable(base)) {\n    // base should be destructed, or will be the same object.\n    tracker = new Proxy(\n      { ...base },\n      {\n        get: (target, prop, receiver) => {\n          if (prop === TRACKER) return Reflect.get(target, prop, receiver);\n          // Take note: Reflect.get will not trigger `get` handler\n          const tracker = Reflect.get(target, TRACKER, receiver);\n          const base = tracker.base;\n          // if key is 'base', should not report and return directly.\n          if (prop === 'base') return base;\n          const value = base[prop];\n          const childrenProxies = tracker['childrenProxies'];\n          const nextPath = path.concat(prop as string);\n\n          reportAccessPaths(nextPath);\n\n          if (isTrackable(value)) {\n            if (!childrenProxies[prop]) {\n              childrenProxies[prop] = new Tracker({\n                base: value,\n                path: nextPath,\n                reportAccessPaths,\n              });\n            } else if (childrenProxies[prop].base !== value) {\n              childrenProxies[prop] = new Tracker({\n                base: value,\n                path: nextPath,\n                reportAccessPaths,\n              });\n            }\n            return childrenProxies[prop];\n          } else if (childrenProxies[prop]) {\n            delete childrenProxies[prop];\n          }\n\n          return value;\n        },\n        set: (target, prop, newValue, receiver) => {\n          return Reflect.set(target, prop, newValue, receiver);\n        },\n      }\n    );\n\n    createHiddenProperty(tracker, TRACKER, {\n      base,\n      childrenProxies: {},\n      effects: [],\n      paths: [],\n    });\n  }\n\n  return tracker;\n} as any) as TrackerConstructor;\n\nexport default Tracker;\n","const joinPath = (path: Array<string>) => path.join('_');\n\ninterface AccessMap {\n  [key: string]: number;\n}\n\nexport const generateRemarkablePaths = (paths: Array<Array<string>>) => {\n  const copy = paths.slice();\n  const accessMap: AccessMap = {};\n  const len = copy.length;\n  const remarkablePaths = [];\n\n  for (let i = len - 1; i >= 0; i--) {\n    const path = copy[i].slice();\n    const pathLength = path.length;\n\n    let isConsecutive = false;\n\n    for (let i = 0; i < pathLength; i++) {\n      const joinedPath = joinPath(path);\n      const count = accessMap[joinedPath] || 0;\n\n      // the intermediate accessed path will be ignored.\n      // https://stackoverflow.com/questions/2937120/how-to-get-javascript-object-references-or-reference-count\n      // because of this, intermediate value may be ignored...\n      if (isConsecutive) {\n        accessMap[joinedPath] = count + 1;\n        path.pop();\n        continue // eslint-disable-line\n      }\n\n      if (!count) {\n        const p = path.slice();\n        const str = joinPath(p);\n        const found = remarkablePaths.find(path => joinPath(path) === str);\n        if (!found) remarkablePaths.push(p);\n        isConsecutive = true;\n        path.pop();\n      } else {\n        accessMap[joinedPath] = count - 1;\n        break;\n      }\n    }\n  }\n\n  return remarkablePaths;\n};\n","import LoadManager from 'LoadManager';\nimport {\n  EffectNodeChildMap,\n  EffectNodeEffectMap,\n  AddChildrenProps,\n} from './types';\n\nclass EffectNode {\n  public childMap: EffectNodeChildMap;\n  public effectMap: EffectNodeEffectMap;\n  private _key: string;\n  readonly _slugKey: string;\n\n  constructor({ key }: { key: string }) {\n    this.childMap = {};\n    this.effectMap = {};\n    this._key = key;\n    this._slugKey = '';\n  }\n\n  getKey() {\n    return this._key;\n  }\n\n  addChild(path: Array<string>, loadManager: LoadManager) {\n    const node = path.reduce<EffectNode>((node, point) => {\n      if (!node.childMap[point])\n        node.childMap[point] = new EffectNode({\n          key: point,\n        });\n      return node.childMap[point];\n    }, this);\n\n    node.addEffect(loadManager);\n  }\n\n  addEffect(loadManager: LoadManager) {\n    const key = loadManager.getKey();\n    this.effectMap[key] = {\n      loadManager,\n    };\n    loadManager.addTeardown(() => delete this.effectMap[key]);\n  }\n\n  addChildren({ paths, loadManager }: AddChildrenProps) {\n    paths.forEach(path => {\n      this.addChild(path, loadManager);\n    });\n  }\n\n  triggerEffect(path: Array<string>) {\n    const node = path.reduce<EffectNode>((node, cur) => {\n      if (node && node.childMap && node.childMap[cur]) {\n        return node.childMap[cur];\n      }\n      return node;\n    }, this);\n\n    for (let key in node.effectMap) {\n      const { loadManager } = node.effectMap[key];\n      loadManager.update();\n    }\n  }\n}\n\nexport default EffectNode;\n","import { EventValue, HalationEvents, ProxyEvent } from './types';\nimport LoadManager from './LoadManager';\nimport Tracker from './Tracker';\nimport { generateRemarkablePaths } from './path';\nimport EffectNode from './EffectNode';\nimport { logActivity } from './logger';\n\nclass EventTracker {\n  public events: HalationEvents;\n  private eventObject: ProxyEvent;\n  private _proxyEvent: ProxyEvent;\n  private currentLoadManager: LoadManager | null;\n  private accessPaths: Array<Array<string>>;\n  private effectNodeTree: EffectNode;\n\n  constructor(props: { events: HalationEvents }) {\n    const { events } = props;\n    this.events = events;\n    this.eventObject = this.initEventObject();\n    this._proxyEvent = new Tracker({\n      path: [],\n      base: this.eventObject,\n      reportAccessPaths: this.reportAccessPaths.bind(this),\n    });\n\n    this.accessPaths = [];\n    this.effectNodeTree = new EffectNode({\n      key: 'root',\n    });\n\n    this.currentLoadManager = null;\n  }\n\n  /**\n   *\n   * @param eventValue\n   * 目前先做到第一层的比较\n   */\n  updateEventValue(eventValue: EventValue) {\n    const { event, value } = eventValue;\n    const baseEventValue = this._proxyEvent[event];\n\n    if (baseEventValue !== value) {\n      this._proxyEvent[event] = value;\n      // base value should be loaded as well\n      this._proxyEvent.base[event] = value;\n      this.effectNodeTree.triggerEffect([event]);\n    }\n  }\n\n  getProxyEvent() {\n    return this._proxyEvent;\n  }\n\n  reportAccessPaths(paths: Array<string>) {\n    this.accessPaths.push(paths);\n  }\n\n  initEventObject(): {} {\n    return this.events.reduce((acc, cur) => {\n      return { ...acc, [cur]: {} };\n    }, {});\n  }\n\n  setLoadManager(loadManager: LoadManager) {\n    this.accessPaths = [];\n    this.currentLoadManager = loadManager;\n  }\n\n  releaseLoadManager() {\n    const tipPoints = generateRemarkablePaths(this.accessPaths);\n    if (this.currentLoadManager) {\n      this.effectNodeTree.addChildren({\n        paths: tipPoints,\n        loadManager: this.currentLoadManager,\n      });\n    }\n\n    logActivity('EventTracker', {\n      message: `add effects to loadManager ${this.currentLoadManager?.getKey()}`,\n    });\n\n    this.currentLoadManager = null;\n  }\n\n  addEffect() {}\n}\n\nexport default EventTracker;\n","import React, {\n  FC,\n  Fragment,\n  createElement,\n  PureComponent,\n  FunctionComponentElement,\n} from 'react';\nimport { SyncHook } from 'tapable';\nimport {\n  Refs,\n  Hooks,\n  Store,\n  PropsAPI,\n  Strategy,\n  ModuleMap,\n  HalationProps,\n  BlockRenderFn,\n  BlockNodeProps,\n  RegisterResult,\n  LoadManagerMap,\n  EventValue,\n} from './types';\nimport Node from './Node';\nimport Module from './Module';\nimport { logActivity } from './logger';\nimport BlockNode from './BlockNode';\nimport LoadManager from './LoadManager';\nimport EventTracker from './EventTracker';\nimport { isPlainObject, isString } from './commons';\n\nclass Halation extends PureComponent<HalationProps> {\n  public name: string;\n  public nodeMap: Map<string, Node>;\n  public blockRenderFn?: BlockRenderFn;\n  public halationState: Array<any>;\n  public moduleMap: ModuleMap;\n  public loadManagerMap: LoadManagerMap;\n  private rootRenderFn?: FC<PropsAPI>;\n  public hooks: Hooks;\n  public runtimeRegisterModule: Map<string, any>;\n  private _refs: Refs;\n  public eventTracker: EventTracker;\n  public store: Store;\n\n  constructor(props: HalationProps) {\n    super(props);\n    const {\n      name,\n      store,\n      events,\n      registers,\n      blockRenderFn,\n      halationState,\n      rootRenderFn,\n    } = props;\n    this.halationState = halationState;\n    this.blockRenderFn = blockRenderFn;\n    this.nodeMap = new Map();\n    this.name = name;\n    this.moduleMap = new Map();\n    this.loadManagerMap = new Map();\n    this.rootRenderFn = rootRenderFn;\n    this.hooks = {\n      register: new SyncHook(['block']),\n    };\n    this._refs = {};\n\n    this.runtimeRegisterModule = new Map();\n\n    this.eventTracker = new EventTracker({\n      events: events || [],\n    });\n\n    this.createBlockNode(this.halationState);\n    this.startListen();\n    this.store = store;\n\n    registers.forEach(register => {\n      const moduleProps: RegisterResult = register.call(null);\n      const { name, getModel, getComponent, strategies } = moduleProps;\n      if (!this.moduleMap.get(name)) {\n        const module = new Module({\n          name,\n          getComponent,\n          getModel,\n          strategies: strategies || [],\n        });\n        this.moduleMap.set(name, module);\n      }\n    });\n  }\n\n  startListen() {\n    for (let key in this.hooks) {\n      const hook = this.hooks[key as keyof Hooks];\n      hook.tap(key, function() {});\n\n      hook.intercept({\n        register: tabInfo => {\n          logActivity('Halation', {\n            message: 'register info',\n            value: tabInfo,\n          });\n          return tabInfo;\n        },\n      });\n    }\n  }\n\n  getName() {\n    return this.name;\n  }\n\n  createBlockNode(list: Array<any>) {\n    list.forEach(item => {\n      const { key } = item;\n      this.nodeMap.set(key, new Node(item));\n    });\n\n    logActivity('Halation', {\n      message: 'finish to create nodes ',\n      value: this.nodeMap,\n    });\n  }\n\n  public getRefs(): Refs {\n    return this._refs;\n  }\n\n  public getPropsAPI(): PropsAPI {\n    return {\n      hooks: this.hooks,\n      nodeMap: this.nodeMap,\n      moduleMap: this.moduleMap,\n      loadManagerMap: this.loadManagerMap,\n      refs: this.getRefs(),\n      addBlockLoadManager: this.addBlockLoadManager.bind(this),\n    };\n  }\n\n  public addBlockLoadManager({\n    blockKey,\n    moduleName,\n    strategies,\n  }: {\n    blockKey: string;\n    moduleName: string;\n    strategies: Array<Strategy>;\n  }): boolean {\n    if (this.loadManagerMap.get(blockKey)) {\n      logActivity('Halation', {\n        message: `Duplicated module key ${blockKey} is registered in halation application`,\n      });\n      return false;\n    }\n\n    this.loadManagerMap.set(\n      blockKey,\n      new LoadManager({\n        store: this.store,\n        blockKey,\n        strategies,\n        moduleName,\n        moduleMap: this.moduleMap,\n        dispatchEvent: this.dispatchEvent.bind(this),\n        proxyEvent: this.eventTracker.getProxyEvent(),\n        lockCurrentLoadManager: this.lockCurrentLoadManager.bind(this),\n        releaseCurrentLoadManager: this.releaseCurrentLoadManager.bind(this),\n      })\n    );\n\n    return true;\n  }\n\n  lockCurrentLoadManager(loadManager: LoadManager) {\n    this.eventTracker.setLoadManager(loadManager);\n  }\n\n  releaseCurrentLoadManager() {\n    this.eventTracker.releaseLoadManager();\n  }\n\n  dispatchEvent(event: string | object) {\n    let nextValue = event;\n\n    if (isString(event)) {\n      nextValue = {\n        event,\n        value: true,\n      };\n    }\n\n    if (isPlainObject(nextValue)) {\n      this.eventTracker.updateEventValue(nextValue as EventValue);\n    }\n  }\n\n  render() {\n    const blocks = this.nodeMap.values();\n    let block = blocks.next().value;\n    const children: Array<FunctionComponentElement<BlockNodeProps>> = [];\n\n    while (block) {\n      children.push(\n        createElement<BlockNodeProps>(\n          BlockNode,\n          {\n            block,\n            key: block.getKey(),\n            blockRenderFn: this.blockRenderFn,\n            ...this.getPropsAPI(),\n          },\n          null\n        )\n      );\n      const blockKey = block.getNextSibling();\n      block = this.nodeMap.get(blockKey);\n    }\n\n    if (typeof this.rootRenderFn === 'function') {\n      return React.createElement(\n        this.rootRenderFn,\n        {\n          ...this.getPropsAPI(),\n        },\n        children\n      );\n    }\n\n    return React.createElement(Fragment, {}, children);\n  }\n}\n\nexport default Halation;\n"],"names":["ModuleName","ModuleStatus","StrategyType","Node","props","type","prevSibling","nextSibling","children","name","strategies","key","getChildKeys","this","getNextSibling","getPrevSibling","getName","getKey","getType","getStrategies","getRenderProps","logActivity","moduleName","process","Module","getModel","getComponent","_name","_getModel","_getComponent","statusMap","Map","Model","Idle","Component","resolversMap","resolvedModulesMap","_strategies","resolveModule","module","__esModule","load","getter","currentStatus","get","Loaded","Promise","resolve","_this","push","set","Pending","fn","call","then","rawModule","forEach","resolver","message","console","error","loadModel","loadComponent","toString","Function","bind","Object","prototype","isPromise","o","TRACKER","Symbol","isTrackable","indexOf","BlockWrapper","hooks","block","moduleMap","loadManagerMap","blockRenderFn","useState","wrapper","setWrapper","blockKey","blockRef","useRef","isLoadingRef","isMountedRef","loadManager","unsubscribeLoadRoutine","loadRoutine","useCallback","shouldLoadModule","shouldModuleLoad","falsy","loadAndForceUpdate","forceUpdate","result","modelResult","componentResult","state","success","model","value","current","ps","register","component","all","map","p","reflect","bindLoadRoutine","blockRenderer","RefForwardingWrapper","forwardRef","ref","createElement","$_modelKey","React","Fragment","BlockNode","nodeMap","addBlockLoadManager","rest","childKeys","invariant","childKey","node","LoadManager","store","proxyEvent","dispatchEvent","lockCurrentLoadManager","releaseCurrentLoadManager","_key","_store","sort","_moduleName","_moduleMap","_lockCurrentLoadManager","_releaseCurrentLoadManager","_proxyEvent","_dispatchEvent","teardownEffects","_runtimeVerifyEffect","_loadRoutine","addTeardown","teardown","typeMap","flags","event","runtime","a","b","update","mountModel","modelInstance","initialValue","modelKey","injectModel","getState","subscribe","startVerifyRuntime","modelCreator","_this$_moduleMap$get","m","err","len","length","i","strategy","_this2","Tracker","base","path","reportAccessPaths","tracker","Proxy","target","prop","receiver","Reflect","childrenProxies","nextPath","concat","newValue","defineProperty","effects","paths","enumerable","writable","joinPath","join","EffectNode","childMap","effectMap","_slugKey","addChild","reduce","point","addEffect","addChildren","triggerEffect","cur","EventTracker","events","eventObject","initEventObject","accessPaths","effectNodeTree","currentLoadManager","updateEventValue","eventValue","getProxyEvent","acc","setLoadManager","releaseLoadManager","tipPoints","copy","slice","accessMap","remarkablePaths","pathLength","isConsecutive","joinedPath","count","pop","str","find","generateRemarkablePaths","_this$currentLoadMana","registers","rootRenderFn","halationState","SyncHook","_refs","runtimeRegisterModule","eventTracker","createBlockNode","startListen","moduleProps","hook","tap","intercept","tabInfo","list","item","getRefs","getPropsAPI","refs","nextValue","isPlainObject","render","values","next","PureComponent"],"mappings":"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"}